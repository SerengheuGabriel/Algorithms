# -*- coding: utf-8 -*-
"""Copy of A*_BestFirst_Pathfinding.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tzzH2BPiVpKRcCLKVn9e6Qft-XvoYYlc
"""

#Best First Search
cityNames =["Amsterdam","Athens","Barcelona","Belgrade","Berlin","Bordeaux","Bucharest","Budapest","Copenhagen","Dublin","Glasgow","Helsinki","Lisbon","London","Lyon","Madrid","Milan","Munich","Oslo","Palermo","Paris","Prague","Rome","Sofia","Stockholm","Vienna","Warsaw","Fail"]

adjacency = [[4,10],[6,19],[14,15,22],[23,7],[0,8,21],[14,20],[1,7,26],[3,6,25],[4,24,26],[10,13],[0,9,13],[18,24],[13,15],[9,10,12,20],[2,5,17,20],[2,12],[7,22],[14,25],[11,24],[1,22],[5,13,14],[4,7,25],[2,16,19],[3],[8,11,18],[17,21],[6,8]]
distance=[2280,1300,2670,630,1800,2100,0,900,2250,2530,2470,2820,3950,2590,1660,3300,1750,1600,2870,1280,2970,1490,1140,390,2890,1150,946,90000]
L = dict()
L[27] = 5000

def route_best_first(city,pos):
  
  print(pos,": ",cityNames[city])
  if city==6: #6=Bucharest, hardcoded because of values
    return True
  if city==27:
    return False
  
  print("New nodes:", end = " ")
  for nextCity in adjacency[city]:
    if nextCity not in L:
      print(cityNames[nextCity], end =" ")
      print(distance[nextCity], end ="; ")
      L[nextCity]=distance[nextCity]
    #if distance[nextCity]<distanceCurrent:
    #  nextNode=nextCity
    #  distanceCurrent=distance[nextCity]
  if len(L)!=0:
    nextNode = min(L,key=lambda o:L[o])
  else:
    nextNode=27
  print("\n\nNext Node:", end = " ")
  print(L[nextNode])
  del L[nextNode]
  route_best_first(nextNode,pos+1)

#A*
cityNames =["Amsterdam","Athens","Barcelona","Belgrade","Berlin","Bordeaux","Bucharest","Budapest","Copenhagen","Dublin","Glasgow","Helsinki","Lisbon","London","Lyon","Madrid","Milan","Munich","Oslo","Palermo","Paris","Prague","Rome","Sofia","Stockholm","Vienna","Warsaw","Fail"]

adjacency = [[4,10],[6,19],[14,15,22],[23,7],[0,8,21],[14,20],[1,7,26],[3,6,25],[4,24,26],[10,13],[0,9,13],[18,24],[13,15],[9,10,12,20],[2,5,17,20],[2,12],[7,22],[14,25],[11,24],[1,22],[5,13,14],[4,7,25],[2,16,19],[3],[8,11,18],[17,21],[6,8]]
adjacencyDist = [[648,711],[1300,907],[644,628,1471],[330,316],[648,743,354],[542,579],[1300,900,946],[316,900,217],[743,522,668],[306,463],[711,306,667],[970,400],[2210,638],[463,667,2210,414],[644,542,753,481],[628,638],[789,681],[753,458],[970,570],[907,1043],[579,414,481],[354,443,312],[1471,681,1043],[330],[522,400,570],[458,312],[946,668]]
distance=[2280,1300,2670,630,1800,2100,0,900,2250,2530,2470,2820,3950,2590,1660,3300,1750,1600,2870,1280,2970,1490,1140,390,2890,1150,946,90000]
open_set, closed_set = dict(), dict()

#dest = 6 (Bucharest)
def route_a_star(start_city):
  open_set.clear()
  closed_set.clear()
  open_set[start_city]=[0,-1]
  open_set[27] = [90000,-1]
  while 1:
    nextNode = min(open_set,key=lambda o:open_set[o][0]+distance[o])
    print("New node:",cityNames[nextNode],":",open_set[nextNode][0]+distance[nextNode])
    if nextNode==6: #goal
      print()
      print("Route:")
      print(cityNames[6])
      currentNode = open_set[6][1]
      while currentNode!=-1:
        print(cityNames[currentNode])
        currentNode=closed_set[currentNode][1]
      break
    if nextNode==27: #fail
      print("No route found!")
      break
    #for nextCity in adjacency[nextNode]:
    j=0
    print("Neighbours:",end=" ")
    while j<len(adjacency[nextNode]):
      nextCity = adjacency[nextNode][j]
      if nextCity in closed_set:
        if closed_set[nextCity][0]>open_set[nextNode][0]+adjacencyDist[nextNode][j]:
          open_set[nextCity][0] = open_set[nextNode][0]+adjacencyDist[nextNode][j]
          del closed_set[nextCity]
          print(cityNames[nextCity],":",open_set[nextCity][0],end =" ")
        j+=1
        continue
      if nextCity not in open_set:
        open_set[nextCity] = [open_set[nextNode][0]+adjacencyDist[nextNode][j],nextNode]
        print(cityNames[nextCity],":",open_set[nextCity][0],end =" ")
      else:
        if open_set[nextCity][0]>open_set[nextNode][0]+adjacencyDist[nextNode][j]:
          open_set[nextCity] = [open_set[nextNode][0]+adjacencyDist[nextNode][j],nextNode]
          print(cityNames[nextCity],":",open_set[nextCity][0],end =" ")
      j+=1
    closed_set[nextNode] = open_set[nextNode]
    del open_set[nextNode]
    print()

route_a_star(20)

L.clear()

route_best_first(20,0)

#Ex2 - Grafic
import matplotlib.pyplot as plt
plt.fill([134,150,242,290,230],[247,162,142,249,332],"k",[162,162,425,425],[18,100,100,18],"k",[295,366,339],[135,135,266],"k",[373,373,438,484],[221,325,333,285],"k",[437,464,518],[180,60,112],"k",[497,608,608,497],[152,152,324,324],"k",[621,677,692,662],[302,133,294,325],"k",[619,561,561,612,666,666],[144,105,44,13,44,105],"k")
plt.plot([0,0],[0,400],'k',[0,800],[400,400],'k',[800,800],[400,0],'k',[800,0],[0,0],'k')
plt.show()

#Ex2 - b_algorithm)
import numpy as np
import matplotlib.pyplot as plt
from shapely.geometry import Point,Polygon, LineString
import math

S = [138,55]
G = [708,320]

motion = [[1, 0, 1],[0, 1, 1],[-1, 0, 1],[0, -1, 1], [-1, -1, math.sqrt(2)], [-1, 1, math.sqrt(2)],[1, -1, math.sqrt(2)],[1, 1, math.sqrt(2)]]

v_p1 = np.array([[136,244], [151,163], [243,144], [288,246], [231,330]])
v_p2 = np.array([[163,19], [163,99], [424,100], [424,19]])
v_p3 = np.array([[296,136], [365,136], [331,265]])
v_p4 = np.array([[374,222], [374,323], [437,331], [483,287]])
v_p5 = np.array([[438,178], [465,61], [516,111]])
v_p6 = np.array([[498,153], [607,153], [607,323], [498,323]])
v_p7 = np.array([[622,300], [675,135], [690,295], [663,322]])
v_p8 = np.array([[617,142], [563,103], [563,46], [610,15],[664,46],[664,105]])

poly_point = [ [134,247], [150,162], [242,142], [290,249], [230,332], [162,18], 
              [162,100], [425,100], [425,18], [295,135], [365,135], [330,266], 
              [373,221], [373,325], [438,333], [484,285], [437,180], [464,60], 
              [518,112], [497,152], [608,152], [608,324], [497,324], [621,302], 
              [677,133], [692,294], [662,325], [619,144], [561,105], [561,44], 
              [612,13],[666,44],[666,108] ]

poly1 = Polygon(v_p1)
poly2 = Polygon(v_p2)
poly3 = Polygon(v_p3)
poly4 = Polygon(v_p4)
poly5 = Polygon(v_p5)
poly6 = Polygon(v_p6)
poly7 = Polygon(v_p7)
poly8 = Polygon(v_p8)
"""
plt.plot([0,0],[0,400],'k',[0,800],[400,400],'k',[800,800],[400,0],'k',[800,0],[0,0],'k')
plt.plot(*poly1.exterior.xy)
plt.plot(*poly2.exterior.xy)
plt.plot(*poly3.exterior.xy)
plt.plot(*poly4.exterior.xy)
plt.plot(*poly5.exterior.xy)
plt.plot(*poly6.exterior.xy)
plt.plot(*poly7.exterior.xy)
plt.plot(*poly8.exterior.xy)
"""
#plt.show()

def intersect():
  line = LineString([(S[0], S[1]),(G[0], G[1])])
  return line.intersects(poly2)

open_set, closed_set = dict(), dict()

def point_hash(x,y):
  return x*1000+y

def calc_heuristic(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)

def movement(x_start,y_start, x_goal, y_goal):
  next_node_list = []
  for i in poly_point:
    if verify_line(x_start, y_start, i[0], i[1]):
      next_node_list.append(i)
  if verify_line(x_start, y_start, x_goal, y_goal):
    next_node_list.append([x_goal, y_goal])
  return next_node_list

def point_is_valid(x,y):
  #X = [0,800];Y= [0,400]
  point = Point(x,y)
  if(point.within(poly1)):
    return False
  if(point.within(poly2)):
    return False
  if(point.within(poly3)):
    return False
  if(point.within(poly4)):
    return False
  if(point.within(poly5)):
    return False
  if(point.within(poly6)):
    return False
  if(point.within(poly7)):
    return False
  if(point.within(poly8)):
    return False
  if(x<=0):
    return False
  if(x>=800):
    return False
  if(y<=0):
    return False
  if(y>=400):
    return False
  return True

def verify_line(x_start, y_start, x_final, y_final):
  line = LineString([(x_start, y_start),(x_final, y_final)])
  if line.intersects(poly1):
    return False
  if line.intersects(poly2):
    return False
  if line.intersects(poly3):
    return False
  if line.intersects(poly4):
    return False
  if line.intersects(poly5):
    return False
  if line.intersects(poly6):
    return False
  if line.intersects(poly7):
    return False
  if line.intersects(poly8):
    return False
  return True
  

def a_star(x_start,y_start,x_goal,y_goal):
  open_set.clear()
  closed_set.clear()
  open_set[point_hash(x_start,y_start)]=[x_start,y_start,0,-1]
  
  plt.plot(*poly1.exterior.xy,'k')
  plt.plot(*poly2.exterior.xy,'k')
  plt.plot(*poly3.exterior.xy,'k')
  plt.plot(*poly4.exterior.xy,'k')
  plt.plot(*poly5.exterior.xy,'k')
  plt.plot(*poly6.exterior.xy,'k')
  plt.plot(*poly7.exterior.xy,'k')
  plt.plot(*poly8.exterior.xy,'k')
  plt.plot([0,0],[0,400],'k',[0,800],[400,400],'k',[800,800],[400,0],'k',[800,0],[0,0],'k')
  
  while 1:
    if len(open_set) == 0:
      print("Fail")
      plt.plot(x_start,y_start,color="magenta",marker="x",markersize=5)
      plt.plot(x_goal,y_goal,color="blue",marker="x",markersize=5)
      plt.show()
      return 0
      break
    current_id = min(open_set,key=lambda o:open_set[o][2]+calc_heuristic(open_set[o][0],open_set[o][1],x_goal,y_goal))
    
    current_x=current_id//1000
    current_y=current_id%1000

    #print(current_x,current_y)
    if(current_x==x_goal and current_y==y_goal):
      print(open_set[current_id][2])
      print("Goal")
      break


    current_element = open_set[current_id]

    #plt.plot(current_element[0],current_element[1],color="green",marker="x",markersize=1)
    #print(current_element)

    closed_set[current_id] = current_element
    del open_set[current_id]
    
    list_next_nodes = movement(current_x, current_y, x_goal, y_goal)

    for i in list_next_nodes:

      next_element = [i[0],i[1],calc_heuristic(current_x,current_y,i[0],i[1])+current_element[2],current_id]

      next_id = point_hash(next_element[0],next_element[1])

      if not point_is_valid(next_element[0],next_element[1]):
        continue
      if next_id in closed_set:
        continue
      if next_id not in open_set:
        open_set[next_id] = next_element
      else:
        if open_set[next_id][2] > next_element[2]:
          open_set[next_id] = next_element
  x_plot = [current_x]
  y_plot = [current_y]

  
  plt.plot(x_start,y_start,color="magenta",marker="x",markersize=5)
  plt.plot(x_goal,y_goal, color="blue",marker="x",markersize=5)
  final_cost = open_set[current_id][2]
  current_id = open_set[current_id][3]
  while current_id!=-1:
    x_plot.append(closed_set[current_id][0])
    y_plot.append(closed_set[current_id][1])
    current_id=closed_set[current_id][3]

  plt.plot(x_plot,y_plot,'r')
  plt.show()
  return 1000-final_cost

#Ex2 - d)
import numpy as np
import matplotlib.pyplot as plt
from shapely.geometry import Point,Polygon
import math

S = [138,55]
G = [708,320]
d=1
motion = [[d, 0, d],[0, d, d],[-d, 0, d],[0, -d, d], [-d, -d, d*math.sqrt(2)], [-1, 1, d*math.sqrt(2)],[1, -1, d*math.sqrt(2)],[1, 1, d*math.sqrt(2)]]

v_p1 = np.array([[134,247], [150,162], [242,142], [290,249], [230,332]])
v_p2 = np.array([[162,18], [162,100], [425,100], [425,18]])
v_p3 = np.array([[295,135], [365,135], [330,266]])
v_p4 = np.array([[373,221], [373,325], [438,333], [484,285]])
v_p5 = np.array([[437,180], [464,60], [518,112]])
v_p6 = np.array([[497,152], [608,152], [608,324], [497,324]])
v_p7 = np.array([[621,302], [677,133], [692,294], [662,325]])
v_p8 = np.array([[619,144], [561,105], [561,44], [612,13],[666,44],[666,108]])

poly1 = Polygon(v_p1)
poly2 = Polygon(v_p2)
poly3 = Polygon(v_p3)
poly4 = Polygon(v_p4)
poly5 = Polygon(v_p5)
poly6 = Polygon(v_p6)
poly7 = Polygon(v_p7)
poly8 = Polygon(v_p8)
"""
plt.plot([0,0],[0,400],'k',[0,800],[400,400],'k',[800,800],[400,0],'k',[800,0],[0,0],'k')
plt.plot(*poly1.exterior.xy)
plt.plot(*poly2.exterior.xy)
plt.plot(*poly3.exterior.xy)
plt.plot(*poly4.exterior.xy)
plt.plot(*poly5.exterior.xy)
plt.plot(*poly6.exterior.xy)
plt.plot(*poly7.exterior.xy)
plt.plot(*poly8.exterior.xy)
"""
#plt.show()


open_set, closed_set = dict(), dict()

def point_hash(x,y):
  return x*1000+y

def calc_heuristic(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)

def point_is_valid(x,y):
  #X = [0,800];Y= [0,400]
  point = Point(x,y)
  if(point.within(poly1)):
    return False
  if(point.within(poly2)):
    return False
  if(point.within(poly3)):
    return False
  if(point.within(poly4)):
    return False
  if(point.within(poly5)):
    return False
  if(point.within(poly6)):
    return False
  if(point.within(poly7)):
    return False
  if(point.within(poly8)):
    return False
  if(x<=0):
    return False
  if(x>=800):
    return False
  if(y<=0):
    return False
  if(y>=400):
    return False
  return True
  
def a_star(x_start,y_start,x_goal,y_goal):
  open_set.clear()
  closed_set.clear()
  open_set[point_hash(x_start,y_start)]=[x_start,y_start,0,-1]
  
  plt.plot(*poly1.exterior.xy,'k')
  plt.plot(*poly2.exterior.xy,'k')
  plt.plot(*poly3.exterior.xy,'k')
  plt.plot(*poly4.exterior.xy,'k')
  plt.plot(*poly5.exterior.xy,'k')
  plt.plot(*poly6.exterior.xy,'k')
  plt.plot(*poly7.exterior.xy,'k')
  plt.plot(*poly8.exterior.xy,'k')
  plt.plot([0,0],[0,400],'k',[0,800],[400,400],'k',[800,800],[400,0],'k',[800,0],[0,0],'k')
  
  while 1:
    if len(open_set) == 0:
      print("Fail")
      plt.plot(x_start,y_start,color="yellow",marker="x",markersize=5)
      plt.plot(x_goal,y_goal,color="blue",marker="x",markersize=5)
      plt.show()
      return 0
      break
    current_id = min(open_set,key=lambda o:open_set[o][2]+calc_heuristic(open_set[o][0],open_set[o][1],x_goal,y_goal))
    
    current_x=current_id//1000
    current_y=current_id%1000

    #print(current_x,current_y)
    if(current_x==x_goal and current_y==y_goal):
      print(open_set[current_id][2])
      print("Goal")
      break


    current_element = open_set[current_id]

    plt.plot(current_element[0],current_element[1],color="green",marker="x",markersize=1)
    #print(current_element)

    closed_set[current_id] = current_element
    del open_set[current_id]
    
    for i in range(0,8):
      next_element = [current_element[0]+motion[i][0],current_element[1]+motion[i][1],current_element[2]+motion[i][2],current_id]

      next_id = point_hash(next_element[0],next_element[1])

      if not point_is_valid(next_element[0],next_element[1]):
        continue
      if next_id in closed_set:
        continue
      if next_id not in open_set:
        open_set[next_id] = next_element
      else:
        if open_set[next_id][2] > next_element[2]:
          open_set[next_id] = next_element
  x_plot = [current_x]
  y_plot = [current_y]
  final_cost = open_set[current_id][2]
  current_id = open_set[current_id][3]
  while current_id!=-1:
    x_plot.append(closed_set[current_id][0])
    y_plot.append(closed_set[current_id][1])
    current_id=closed_set[current_id][3]

  plt.plot(x_plot,y_plot,'r')
  plt.plot(x_start,y_start,color="yellow",marker="x",markersize=5)
  plt.plot(x_goal,y_goal,color="blue",marker="x",markersize=5)
  plt.show()
  return 1000-final_cost

#Ex2 - b_rand)
from random import randint

#a_star(S[0],S[1],G[0],G[1])
sum_cost=0
idx=0
for i in range(100):
  x = randint(0,800)
  y = randint(0,400)
  
  while not point_is_valid(x,y):
    x = randint(0,800)
    y = randint(0,400)
  
  print("Index:",idx,"Start:",x,y)
  sum_cost+=a_star(x,y,G[0],G[1])
  print(sum_cost)
  idx+=1

#verify_line(162,100,365,135)

a_star(S[0],S[1],G[0],G[1])
#a_star(1,1,80,40)

"""Wir gehen zwischen Polygonknoten weil es am ahnlichsten einer direkten Gerade zwischen Start- un Endpunkt ist. Zustandsraum = undendlich (wir wissen nicht die genaue Lange einer Strecke). Zustandsraum fur b ware = 35 (33 Knoten + 1 Startpunkt + 1 Zielpunkt)

"""