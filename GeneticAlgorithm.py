# -*- coding: utf-8 -*-
"""Copy of Labor4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xeeqb-__JePklEGcG7_XCHCAcJ3Dhg7f
"""

#Random Points + Graphics
import random
import math
import matplotlib.pyplot as plt
pointcount=100
def calc_distance(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)

points=[]
for i in range(pointcount):
  x = random.randint(0,800)
  y = random.randint(0,400)
  points.append([x,y])
#print(points)

for i in range(pointcount):
  points[i].append([])
  for j in range(pointcount):
      points[i][2].append(calc_distance(points[i][0],points[i][1],points[j][0],points[j][1]))
  #print(points[i][2])

for i in range(pointcount):
  plt.plot(points[i][0],points[i][1],markersize=5, marker="X")#,color='k'
x_plot=[]
y_plot=[]
for i in range(pointcount):
  x_plot.append(points[i][0])
  y_plot.append(points[i][1])

plt.plot(x_plot,y_plot,'r')
plt.show()

#Recombination
import random
a = random.sample(range(1, 10), 9)
a.insert(0,0)
b = random.sample(range(1, 10), 9)
b.insert(0,0)

def basic_recombination(parent1,parent2): 
  child = parent1[0:int(len(parent1)/2)]
  for i in parent2:
    if i not in child:
      child.append(i)
  return child

def advanced_recombination(parent1,parent2): 
  
  adjacency = []
  for i in range(0,len(parent1)):
    adjacency.append([])
    
  if parent1[1] not in adjacency[parent1[0]]:
    adjacency[parent1[0]].append(parent1[1])

  if parent1[len(parent1)-1] not in adjacency[parent1[0]]:
    adjacency[parent1[0]].append(parent1[len(parent1)-1])
  
  if parent2[1] not in adjacency[parent2[0]]:
    adjacency[parent2[0]].append(parent2[1])

  if parent2[len(parent1)-1] not in adjacency[parent2[0]]:
    adjacency[parent2[0]].append(parent2[len(parent1)-1])

  if parent1[0] not in adjacency[parent1[len(parent1)-1]]:
    adjacency[parent1[len(parent1)-1]].append(parent1[0])

  if parent1[len(parent1)-2] not in adjacency[parent1[len(parent1)-1]]:
    adjacency[parent1[len(parent1)-1]].append(parent1[len(parent1)-2])
  
  if parent2[0] not in adjacency[parent2[len(parent1)-1]]:
    adjacency[parent2[len(parent1)-1]].append(parent2[0])

  if parent2[len(parent1)-2] not in adjacency[parent2[len(parent1)-1]]:
    adjacency[parent2[len(parent1)-1]].append(parent2[len(parent1)-2])
  
  for i in range(1,len(parent1)-1):
    if parent1[i-1] not in adjacency[parent1[i]]:
      adjacency[parent1[i]].append(parent1[i-1])
    if parent1[i+1] not in adjacency[parent1[i]]:
      adjacency[parent1[i]].append(parent1[i+1])
    if parent2[i-1] not in adjacency[parent2[i]]:
      adjacency[parent2[i]].append(parent2[i-1])
    if parent2[i+1] not in adjacency[parent2[i]]:
      adjacency[parent2[i]].append(parent2[i+1])
  
  for i in adjacency[0]:
    adjacency[i].remove(0)
  adjacency[0]=[]
  child=[0]
  while(len(child)<len(parent1)):
    minlist=[]
    minadj=5
    #print(adjacency)
    #print(len(adjacency))
    for i in range(0,len(adjacency)):
      #print(i)
      if len(adjacency[i])!=0:
        if len(adjacency[i])<minadj:
          minlist=[]
          minadj=len(adjacency[i])
        if len(adjacency[i])==minadj:
          minlist.append(i)
    #print(minlist)
    if len(minlist)!=0:
      elem=random.sample(minlist,1)
      #print(elem[0])
    
      child.append(elem[0])
      for i in adjacency[elem[0]]:
          adjacency[i].remove(elem[0])
      adjacency[elem[0]]=[]
    else:
      for i in range(0,len(adjacency)):
        if i not in child:
          child.append(i)
  return child

print(a)
print(b)
#print(basic_recombination(a,b))
#print(advanced_recombination(a,b))
print(advanced_recombination([0,1, 2, 3, 4, 8, 5, 6, 7],[0,1, 4, 8, 6, 5, 7, 2, 3]))

#Mutation
import random

def mutation(parent):
  mutationrate=random.randint(0,len(parent))
  if mutationrate<1:  #1% for len=100, len(parent)/2 = 50%
    child=parent
    startmutation=random.randint(1,len(parent)-1)
    endmutation=random.randint(startmutation,len(parent))
    sublist=parent[startmutation:endmutation]
    sublist.reverse()
    child[startmutation:endmutation]=sublist
    return child
  else:
    return parent

import random
import math

pointcount=100
points=[]
for i in range(pointcount):
  x = random.randint(0,800)
  y = random.randint(0,400)
  points.append([x,y])



def calc_distance(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)

def listDistances(listPath):
  distances = []

  for i in range(len(listPath)-1):
    distances.append(calc_distance(points[listPath[i]][0],points[listPath[i]][1],points[listPath[i+1]][0],points[listPath[i+1]][1]))
  distances.append(calc_distance(points[listPath[-1]][0],points[listPath[-1]][1],points[listPath[0]][0],points[listPath[0]][1]))
  return distances

def calcTotalDistance(listPath):
  sum = 0
  for i in listDistances(listPath):
    sum += i
  return sum

def advanced_recombination(parent1,parent2): 
  
  adjacency = []
  for i in range(0,len(parent1)):
    adjacency.append([])
    
  if parent1[1] not in adjacency[parent1[0]]:
    adjacency[parent1[0]].append(parent1[1])

  if parent1[len(parent1)-1] not in adjacency[parent1[0]]:
    adjacency[parent1[0]].append(parent1[len(parent1)-1])
  
  if parent2[1] not in adjacency[parent2[0]]:
    adjacency[parent2[0]].append(parent2[1])

  if parent2[len(parent1)-1] not in adjacency[parent2[0]]:
    adjacency[parent2[0]].append(parent2[len(parent1)-1])

  if parent1[0] not in adjacency[parent1[len(parent1)-1]]:
    adjacency[parent1[len(parent1)-1]].append(parent1[0])

  if parent1[len(parent1)-2] not in adjacency[parent1[len(parent1)-1]]:
    adjacency[parent1[len(parent1)-1]].append(parent1[len(parent1)-2])
  
  if parent2[0] not in adjacency[parent2[len(parent1)-1]]:
    adjacency[parent2[len(parent1)-1]].append(parent2[0])

  if parent2[len(parent1)-2] not in adjacency[parent2[len(parent1)-1]]:
    adjacency[parent2[len(parent1)-1]].append(parent2[len(parent1)-2])
  
  for i in range(1,len(parent1)-1):
    if parent1[i-1] not in adjacency[parent1[i]]:
      adjacency[parent1[i]].append(parent1[i-1])
    if parent1[i+1] not in adjacency[parent1[i]]:
      adjacency[parent1[i]].append(parent1[i+1])
    if parent2[i-1] not in adjacency[parent2[i]]:
      adjacency[parent2[i]].append(parent2[i-1])
    if parent2[i+1] not in adjacency[parent2[i]]:
      adjacency[parent2[i]].append(parent2[i+1])
  
  for i in adjacency[0]:
    adjacency[i].remove(0)
  adjacency[0]=[]
  child=[0]
  while(len(child)<len(parent1)):
    minlist=[]
    minadj=5
    #print(adjacency)
    #print(len(adjacency))
    for i in range(0,len(adjacency)):
      #print(i)
      if len(adjacency[i])!=0:
        if len(adjacency[i])<minadj:
          minlist=[]
          minadj=len(adjacency[i])
        if len(adjacency[i])==minadj:
          minlist.append(i)
    #print(minlist)
    if len(minlist)!=0:
      elem=random.sample(minlist,1)
      #print(elem[0])
    
      child.append(elem[0])
      for i in adjacency[elem[0]]:
          adjacency[i].remove(elem[0])
      adjacency[elem[0]]=[]
    else:
      for i in range(0,len(adjacency)):
        if i not in child:
          child.append(i)
  return child

def sortInitialParents(p1, p2, p3, p4):
  allPaths = [p1,p2,p3,p4]
  allPaths.sort(reverse=False, key = lambda x: x[1])
  max1 = allPaths[0]
  max2 = allPaths[1]
  max3 = allPaths[2]
  max4 = allPaths[3]
  return max1, max2, max3, max4

def mutation(parent):
  mutationrate=random.randint(0,len(parent))
  if mutationrate<1:  #1% for len=100, len(parent)/2 = 50%
    child=parent
    startmutation=random.randint(1,len(parent)-1)
    endmutation=random.randint(startmutation,len(parent))
    sublist=parent[startmutation:endmutation]
    sublist.reverse()
    child[startmutation:endmutation]=sublist
    return child
  else:
    return parent

def sortPaths(p1, p2, p3, p4, c1, c2, c3, c4):
  allPaths = [p1,p2,p3,p4,c1,c2,c3,c4]
  allPaths.sort(reverse=False, key = lambda x: x[1])
  max1 = allPaths[0]
  max2 = allPaths[1]
  max3 = allPaths[2]
  max4 = allPaths[3]
  return max1, max2, max3, max4

def main(nrGen):
  currentGen = 0

  parent1 = [random.sample(range(1, pointcount), pointcount-1)]
  parent1[0].insert(0,0)

  parent1.append(calcTotalDistance(parent1[0]))

  parent2 = [random.sample(range(1, pointcount), pointcount-1)]
  parent2[0].insert(0,0)
  parent2.append(calcTotalDistance(parent2[0]))
  parent3 = [random.sample(range(1, pointcount), pointcount-1)]
  parent3[0].insert(0,0)
  parent3.append(calcTotalDistance(parent3[0]))
  parent4 = [random.sample(range(1, pointcount), pointcount-1)]
  parent4[0].insert(0,0)
  parent4.append(calcTotalDistance(parent4[0]))

  parent1, parent2, parent3, parent4 = sortInitialParents(parent1, parent2, parent3, parent4)
  while currentGen < nrGen:
    print(currentGen)
    print (parent1[1],' ' ,parent2[1],' ' , parent3[1],' ' , parent4[1],' ')
    
    child = []
    for i in range(0,4):
      par1 = None
      par2 = None
      p1used = False
      p2used = False
      p3used = False
      p4used = False
      while (not par1 or not par2):
        chance = random.randint(1,101)
        if chance <= 35 and chance >= 1 and not p1used:
          if not par1:
            par1 = parent1 
            p1used = True
          else:
            if not par2:
              par2 = parent1
              p1used = True
        if chance <= 65 and chance >= 36 and not p2used:
          if not par1:
            par1 = parent2
            p2used = True
          else:
            if not par2:
              par2 = parent2
              p2used = True
        if chance <= 85 and chance >= 66 and not p3used:
          if not par1:
            par1 = parent3
            p3used = True
          else:
            if not par2:
              par2 = parent3
              p3used = True
        if chance <= 100 and chance >= 86 and not p4used:
          if not par1:
            par1 = parent1 
            p4used = True
          else:
            if not par2:
              par2 = parent1
              p4used = True
      #print(par1[0])
      #print(par2[0])
      #print(i)
      child.append([mutation(advanced_recombination(par1[0],par2[0]))])
      #child[i][0] = mutation(advanced_recombination(par1[0],par2[0]))
      child[i].append(calcTotalDistance(child[i][0]))
      #print(child[i])
    print (parent1[1],' ' ,parent2[1],' ' , parent3[1],' ' , parent4[1],' ' , child[0][1], ' ' ,child[1][1],' ' , child[2][1],' ' , child[3][1],'\n' ,'\n' )
    parent1, parent2, parent3, parent4 = sortPaths(parent1, parent2, parent3, parent4, child[0], child[1], child[2], child[3])
    currentGen += 1

#BEST ROUTE
import random
import math
import matplotlib.pyplot as plt

pointcount = 100

points=[]
for i in range(pointcount):
  x = random.randint(0,200)
  y = random.randint(0,200)
  points.append([x,y])
'''
points=[]
for i in range(0,25):
  points.append([0,i*4])

for i in range(0,25):
  points.append([i*4,100])
  
for i in range(0,25):
  points.append([100,i*4])
  
for i in range(0,25):
  points.append([i*4,0])

def calc_distance(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)
'''
def listDistances(listPath):
  distances = []
  for i in range(len(listPath)-1):
    distances.append(calc_distance(points[listPath[i]][0],points[listPath[i]][1],points[listPath[i+1]][0],points[listPath[i+1]][1]))
  distances.append(calc_distance(points[listPath[-1]][0],points[listPath[-1]][1],points[listPath[0]][0],points[listPath[0]][1]))
  return distances

def calcTotalDistance(listPath):
  sum = 0
  for i in listDistances(listPath):
    sum += i
  return sum

def advanced_recombination(parent1,parent2): 
  
  adjacency = []
  for i in range(0,len(parent1)):
    adjacency.append([])
    
  if parent1[1] not in adjacency[parent1[0]]:
    adjacency[parent1[0]].append(parent1[1])

  if parent1[len(parent1)-1] not in adjacency[parent1[0]]:
    adjacency[parent1[0]].append(parent1[len(parent1)-1])
  
  if parent2[1] not in adjacency[parent2[0]]:
    adjacency[parent2[0]].append(parent2[1])

  if parent2[len(parent1)-1] not in adjacency[parent2[0]]:
    adjacency[parent2[0]].append(parent2[len(parent1)-1])

  if parent1[0] not in adjacency[parent1[len(parent1)-1]]:
    adjacency[parent1[len(parent1)-1]].append(parent1[0])

  if parent1[len(parent1)-2] not in adjacency[parent1[len(parent1)-1]]:
    adjacency[parent1[len(parent1)-1]].append(parent1[len(parent1)-2])
  
  if parent2[0] not in adjacency[parent2[len(parent1)-1]]:
    adjacency[parent2[len(parent1)-1]].append(parent2[0])

  if parent2[len(parent1)-2] not in adjacency[parent2[len(parent1)-1]]:
    adjacency[parent2[len(parent1)-1]].append(parent2[len(parent1)-2])
  
  for i in range(1,len(parent1)-1):
    if parent1[i-1] not in adjacency[parent1[i]]:
      adjacency[parent1[i]].append(parent1[i-1])
    if parent1[i+1] not in adjacency[parent1[i]]:
      adjacency[parent1[i]].append(parent1[i+1])
    if parent2[i-1] not in adjacency[parent2[i]]:
      adjacency[parent2[i]].append(parent2[i-1])
    if parent2[i+1] not in adjacency[parent2[i]]:
      adjacency[parent2[i]].append(parent2[i+1])
  
  for i in adjacency[0]:
    adjacency[i].remove(0)
  adjacency[0]=[]
  child=[0]
  while(len(child)<len(parent1)):
    minlist=[]
    minadj=5
    #print(adjacency)
    #print(len(adjacency))
    for i in range(0,len(adjacency)):
      #print(i)
      if len(adjacency[i])!=0:
        if len(adjacency[i])<minadj:
          minlist=[]
          minadj=len(adjacency[i])
        if len(adjacency[i])==minadj:
          minlist.append(i)
    #print(minlist)
    if len(minlist)!=0:
      elem=random.sample(minlist,1)
      #print(elem[0])
    
      child.append(elem[0])
      for i in adjacency[elem[0]]:
          adjacency[i].remove(elem[0])
      adjacency[elem[0]]=[]
    else:
      for i in range(0,len(adjacency)):
        if i not in child:
          child.append(i)
  return child

def sortInitialParents(p1, p2, p3, p4):
  allPaths = [p1,p2,p3,p4]
  allPaths.sort(reverse=False, key = lambda x: x[1])
  max1 = allPaths[0]
  max2 = allPaths[1]
  max3 = allPaths[2]
  max4 = allPaths[3]
  return max1, max2, max3, max4

def mutation(parent):
  mutationrate=random.randint(0,100)
  if mutationrate<100:  #1% for len=100, len(parent)/2 = 50%
    child=parent
    startmutation=random.randint(1,len(parent)-1)
    endmutation=random.randint(startmutation,len(parent))
    sublist=parent[startmutation:endmutation]
    sublist.reverse()
    child[startmutation:endmutation]=sublist
    return child
  else:
    return parent

def sortPaths(p1, p2, p3, p4, c1, c2, c3, c4):
  allPaths = [p1,p2,p3,p4,c1,c2,c3,c4]
  allPaths.sort(reverse=False, key = lambda x: x[1])
  max1 = allPaths[0]
  max2 = allPaths[1]
  max3 = allPaths[2]
  max4 = allPaths[3]
  return max1, max2, max3, max4

def main(nrGen):
  currentGen = 0

  parent1 = [random.sample(range(1, pointcount), pointcount-1)]
  parent1[0].insert(0,0)
  parent1.append(calcTotalDistance(parent1[0]))
  parent2 = [random.sample(range(1, pointcount), pointcount-1)]
  parent2[0].insert(0,0)
  parent2.append(calcTotalDistance(parent2[0]))
  parent3 = [random.sample(range(1, pointcount), pointcount-1)]
  parent3[0].insert(0,0)
  parent3.append(calcTotalDistance(parent3[0]))
  parent4 = [random.sample(range(1, pointcount), pointcount-1)]
  parent4[0].insert(0,0)
  parent4.append(calcTotalDistance(parent4[0]))

  parent1, parent2, parent3, parent4 = sortInitialParents(parent1, parent2, parent3, parent4)
  y_bestDistEv = []
  while currentGen < nrGen:
    #print(parent1[1])
    child = []
    for i in range(0,4):
      par1 = None
      par2 = None
      p1used = False
      p2used = False
      p3used = False
      p4used = False
      while (not par1 or not par2):
        chance = random.randint(1,101)
        if chance <= 35 and chance >= 1 and not p1used:
          if not par1:
            par1 = parent1 
            p1used = True
          else:
            if not par2:
              par2 = parent1
              p1used = True
        if chance <= 65 and chance >= 36 and not p2used:
          if not par1:
            par1 = parent2
            p2used = True
          else:
            if not par2:
              par2 = parent2
              p2used = True
        if chance <= 85 and chance >= 66 and not p3used:
          if not par1:
            par1 = parent3
            p3used = True
          else:
            if not par2:
              par2 = parent3
              p3used = True
        if chance <= 100 and chance >= 86 and not p4used:
          if not par1:
            par1 = parent1 
            p4used = True
          else:
            if not par2:
              par2 = parent1
              p4used = True
      child.append([mutation(advanced_recombination(par1[0],par2[0]))])
      child[i].append(calcTotalDistance(child[i][0]))
    parent1, parent2, parent3, parent4 = sortPaths(parent1, parent2, parent3, parent4, child[0], child[1], child[2], child[3])
    child[0] = mutation(parent1)
    child[1] = mutation(parent2)
    child[2] = mutation(parent3)
    child[3] = mutation(parent4)
    for i in range(0,4):
      child[i].append(calcTotalDistance(child[i][0]))
    parent1, parent2, parent3, parent4 = sortPaths(parent1, parent2, parent3, parent4, child[0], child[1], child[2], child[3])
    currentGen += 1 
    
    

    #if currentGen in {500,1000,1500,2000}:
    if currentGen % 500 == 0  or currentGen == 1:
      print("Current gen: ", currentGen)
      for i in range(pointcount):
        plt.plot(points[i][0],points[i][1],markersize=3, marker="o")
      x_plot=[]
      y_plot=[]
      for i in range(pointcount):
        x_plot.append(points[parent1[0][i]][0])
        y_plot.append(points[parent1[0][i]][1])
      x_plot.append(points[parent1[0][0]][0])
      y_plot.append(points[parent1[0][0]][1])
      plt.plot(x_plot,y_plot,'r')
      plt.show()
    x_something = range(0, nrGen)
    y_bestDistEv.append(parent1[1])
  plt.plot(x_something, y_bestDistEv, marker='o', markersize='1')
  plt.show()

#WORST ROUTE
import random
import math
import matplotlib.pyplot as plt

pointcount = 100
'''
points=[]
for i in range(pointcount):
  x = random.randint(0,800)
  y = random.randint(0,400)
  points.append([x,y])
'''
def calc_distance(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)

def listDistances(listPath):
  distances = []
  for i in range(len(listPath)-1):
    distances.append(calc_distance(points[listPath[i]][0],points[listPath[i]][1],points[listPath[i+1]][0],points[listPath[i+1]][1]))
  distances.append(calc_distance(points[listPath[-1]][0],points[listPath[-1]][1],points[listPath[0]][0],points[listPath[0]][1]))
  return distances

def calcTotalDistance(listPath):
  sum = 0
  for i in listDistances(listPath):
    sum += i
  return sum

def advanced_recombination(parent1,parent2): 
  
  adjacency = []
  for i in range(0,len(parent1)):
    adjacency.append([])
    
  if parent1[1] not in adjacency[parent1[0]]:
    adjacency[parent1[0]].append(parent1[1])

  if parent1[len(parent1)-1] not in adjacency[parent1[0]]:
    adjacency[parent1[0]].append(parent1[len(parent1)-1])
  
  if parent2[1] not in adjacency[parent2[0]]:
    adjacency[parent2[0]].append(parent2[1])

  if parent2[len(parent1)-1] not in adjacency[parent2[0]]:
    adjacency[parent2[0]].append(parent2[len(parent1)-1])

  if parent1[0] not in adjacency[parent1[len(parent1)-1]]:
    adjacency[parent1[len(parent1)-1]].append(parent1[0])

  if parent1[len(parent1)-2] not in adjacency[parent1[len(parent1)-1]]:
    adjacency[parent1[len(parent1)-1]].append(parent1[len(parent1)-2])
  
  if parent2[0] not in adjacency[parent2[len(parent1)-1]]:
    adjacency[parent2[len(parent1)-1]].append(parent2[0])

  if parent2[len(parent1)-2] not in adjacency[parent2[len(parent1)-1]]:
    adjacency[parent2[len(parent1)-1]].append(parent2[len(parent1)-2])
  
  for i in range(1,len(parent1)-1):
    if parent1[i-1] not in adjacency[parent1[i]]:
      adjacency[parent1[i]].append(parent1[i-1])
    if parent1[i+1] not in adjacency[parent1[i]]:
      adjacency[parent1[i]].append(parent1[i+1])
    if parent2[i-1] not in adjacency[parent2[i]]:
      adjacency[parent2[i]].append(parent2[i-1])
    if parent2[i+1] not in adjacency[parent2[i]]:
      adjacency[parent2[i]].append(parent2[i+1])
  
  for i in adjacency[0]:
    adjacency[i].remove(0)
  adjacency[0]=[]
  child=[0]
  while(len(child)<len(parent1)):
    minlist=[]
    minadj=5
    #print(adjacency)
    #print(len(adjacency))
    for i in range(0,len(adjacency)):
      #print(i)
      if len(adjacency[i])!=0:
        if len(adjacency[i])<minadj:
          minlist=[]
          minadj=len(adjacency[i])
        if len(adjacency[i])==minadj:
          minlist.append(i)
    #print(minlist)
    if len(minlist)!=0:
      elem=random.sample(minlist,1)
      #print(elem[0])
    
      child.append(elem[0])
      for i in adjacency[elem[0]]:
          adjacency[i].remove(elem[0])
      adjacency[elem[0]]=[]
    else:
      for i in range(0,len(adjacency)):
        if i not in child:
          child.append(i)
  return child

def sortInitialParents(p1, p2, p3, p4):
  allPaths = [p1,p2,p3,p4]
  allPaths.sort(reverse=True, key = lambda x: x[1])
  max1 = allPaths[0]
  max2 = allPaths[1]
  max3 = allPaths[2]
  max4 = allPaths[3]
  return max1, max2, max3, max4

def mutation(parent):
  mutationrate=random.randint(0,len(parent))
  if mutationrate<1:  #1% for len=100, len(parent)/2 = 50%
    child=parent
    startmutation=random.randint(1,len(parent)-1)
    endmutation=random.randint(startmutation,len(parent))
    sublist=parent[startmutation:endmutation]
    sublist.reverse()
    child[startmutation:endmutation]=sublist
    return child
  else:
    return parent

def sortPaths(p1, p2, p3, p4, c1, c2, c3, c4):
  allPaths = [p1,p2,p3,p4,c1,c2,c3,c4]
  allPaths.sort(reverse=True, key = lambda x: x[1])
  max1 = allPaths[0]
  max2 = allPaths[1]
  max3 = allPaths[2]
  max4 = allPaths[3]
  return max1, max2, max3, max4

def main(nrGen):
  currentGen = 0

  parent1 = [random.sample(range(1, pointcount), pointcount-1)]
  parent1[0].insert(0,0)
  parent1.append(calcTotalDistance(parent1[0]))
  parent2 = [random.sample(range(1, pointcount), pointcount-1)]
  parent2[0].insert(0,0)
  parent2.append(calcTotalDistance(parent2[0]))
  parent3 = [random.sample(range(1, pointcount), pointcount-1)]
  parent3[0].insert(0,0)
  parent3.append(calcTotalDistance(parent3[0]))
  parent4 = [random.sample(range(1, pointcount), pointcount-1)]
  parent4[0].insert(0,0)
  parent4.append(calcTotalDistance(parent4[0]))

  parent1, parent2, parent3, parent4 = sortInitialParents(parent1, parent2, parent3, parent4)
  y_bestDistEv = []
  while currentGen < nrGen:
    #print(parent1[1])
    child = []
    for i in range(0,4):
      par1 = None
      par2 = None
      p1used = False
      p2used = False
      p3used = False
      p4used = False
      while (not par1 or not par2):
        chance = random.randint(1,101)
        if chance <= 35 and chance >= 1 and not p1used:
          if not par1:
            par1 = parent1 
            p1used = True
          else:
            if not par2:
              par2 = parent1
              p1used = True
        if chance <= 65 and chance >= 36 and not p2used:
          if not par1:
            par1 = parent2
            p2used = True
          else:
            if not par2:
              par2 = parent2
              p2used = True
        if chance <= 85 and chance >= 66 and not p3used:
          if not par1:
            par1 = parent3
            p3used = True
          else:
            if not par2:
              par2 = parent3
              p3used = True
        if chance <= 100 and chance >= 86 and not p4used:
          if not par1:
            par1 = parent1 
            p4used = True
          else:
            if not par2:
              par2 = parent1
              p4used = True
      child.append([mutation(advanced_recombination(par1[0],par2[0]))])
      child[i].append(calcTotalDistance(child[i][0]))
    parent1, parent2, parent3, parent4 = sortPaths(parent1, parent2, parent3, parent4, child[0], child[1], child[2], child[3])
    child[0] = mutation(parent1)
    child[1] = mutation(parent2)
    child[2] = mutation(parent3)
    child[3] = mutation(parent4)
    for i in range(0,4):
      child[i].append(calcTotalDistance(child[i][0]))
    parent1, parent2, parent3, parent4 = sortPaths(parent1, parent2, parent3, parent4, child[0], child[1], child[2], child[3])
    currentGen += 1 

    #if currentGen in {500,1000,1500,2000}:
    if currentGen % 500 == 0 or currentGen == 1:
      print("Current gen: ", currentGen)
      for i in range(pointcount):
        plt.plot(points[i][0],points[i][1],markersize=3, marker="o")
      x_plot=[]
      y_plot=[]
      for i in range(pointcount):
        x_plot.append(points[parent1[0][i]][0])
        y_plot.append(points[parent1[0][i]][1])
      x_plot.append(points[parent1[0][0]][0])
      y_plot.append(points[parent1[0][0]][1])
      plt.plot(x_plot,y_plot,'r')
      plt.show()
    x_something = range(0, nrGen)
    y_bestDistEv.append(parent1[1])
  plt.plot(x_something, y_bestDistEv, marker='o', markersize='1')
  plt.show()

'''
def mutation(parent):
  mutationrate=random.randint(0,100)
  if mutationrate<100:  #1% for len=100, len(parent)/2 = 50%
    child=parent
    startmutation=random.randint(1,len(parent)-1)
    endmutation=random.randint(startmutation,len(parent))
    sublist=parent[startmutation:endmutation]
    sublist.reverse()
    child[startmutation:endmutation]=sublist
    return child
  else:
    return parent
'''
def mutation(parent):
  startmutation=random.randint(1,len(parent)-1)
  endmutation=random.randint(1,len(parent)-1)
  temp = parent[startmutation]
  parent[startmutation]=parent[endmutation]
  parent[endmutation]=temp  
  return parent

main(2000)

main(2000)