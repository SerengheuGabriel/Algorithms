# -*- coding: utf-8 -*-
"""Lab5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sf6gU3G7tjbR7XnZtCyilsxWRhNT4cL2
"""

E = [[0, 0], [0, 1], [1, 0], [1, 1]]

def generatePheromones(listPoints):
  pheromones = []
  for i in range(len(listPoints)):
    pheromones.append([])
    for j in range(len(listPoints)):
      pheromones[i].append(0)
  return pheromones

print(generatePheromones(E))

E = [[0, 0], [0, 1], [1, 0], [1, 1]]

def generateDistances(listPoints):
  distances = []
  for i in range(len(listPoints)):
    distances.append([])
    for j in range(len(listPoints)):
      distances[i].append(calc_distance(listPoints[i][0], listPoints[i][1], listPoints[j][0], listPoints[j][1]))
  return distances

print(generateDistances(E))

import math

def calc_distance(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)

points=[]
for i in range(0,25):
  points.append([0,i*4])

for i in range(0,25):
  points.append([i*4,100])
  
for i in range(0,25):
  points.append([100,i*4])
  
for i in range(0,25):
  points.append([i*4,0])

#returns a list of probabilities which edge the ant will follow
def generateProbabilities(currentPoint, remainingPoints):
  probabilities = []
  sumTot = 0
  for i in range(len(points)):
    if i in remainingPoints and i != currentPoint:
      prob = pheromones[currentPoint][i] ** a * (1/distances[currentPoint][i])**b
      probabilities.append(prob)
      sumTot += prob
    else: probabilities.append(0)
  for i in range(len(points)):
    probabilities[i] = probabilities[i] / sumTot
  return probabilities

toBeVisited = [i for i in range(len(points))]
toBeVisited.remove(ants[0])
print(generateProbabilities(ants[0], toBeVisited))

def decayPheromones():
  for i in range(len(pheromones)):
    for j in range(len(pheromones)):
      pheromones[i][j] = (1-p) * (pheromones[i][j])

def setPheromones(route, routeDistance):
  for i in range(len(route)-1):
      pheromones[route[i]][route[i+1]] = (pheromones[route[i]][route[i+1]]) + (Q / routeDistance)

def generateRoute(antStartingCity):
  visited = [antStartingCity]
  toBeVisited = [i for i in range(len(points))]
  toBeVisited.remove(antStartingCity)
  currentCity = antStartingCity
  while toBeVisited != []:
    probabilities = generateProbabilities(currentCity, toBeVisited)
    chance = random.uniform(0, 1)
    i = 0
    s = 0
    while s < chance:
      s += probabilities[toBeVisited[i]]
      i += 1
    i -= 1
    visited.append(toBeVisited[i])
    currentCity = toBeVisited[i]
    toBeVisited.remove(toBeVisited[i])
  return visited

print(generateRoute(ants[0]))

24/6.097560975609756e-05

import math
import random
import sys
import matplotlib.pyplot as plt

def calc_distance(x1,y1,x2,y2):
  return math.hypot(x1 - x2, y1 - y2)

#generate points in a square
'''points=[]
for i in range(0,25):
  points.append([0,i*4])

for i in range(1,24):
  points.append([i*4,100])
  
for i in range(0,25):
  points.append([100,i*4])
  
for i in range(1,24):
  points.append([i*4,0])'''

#variables for easy changes
# a = concentration of pheromones
# b = range of view
# p = (1-p) for decay rate
# Q = Q/weight
# pointcount = nr of cities
pointcount = 100
a = 1
b = 2
p = 0.10
Q = 1000

points = []

for i in range(pointcount):
  x = random.randint(0,1000)
  y = random.randint(0,1000)
  while [x,y] in points:
    x = random.randint(0,1000)
    y = random.randint(0,1000)
  points.append([x,y])

#generate weighted adjMatrix (weight=length of edge)
def generateDistances(listPoints):
  distances = []
  for i in range(len(listPoints)):
    distances.append([])
    for j in range(len(listPoints)):
      distances[i].append(calc_distance(listPoints[i][0], listPoints[i][1], listPoints[j][0], listPoints[j][1]))
  return distances
  
distances = generateDistances(points)
#print(distances)

#initialize weighted adjMatrix with 1 (weight=phCount)
def generatePheromones(listPoints):
  pheromones = []
  for i in range(len(listPoints)):
    pheromones.append([])
    for j in range(len(listPoints)):
      pheromones[i].append(1)
  return pheromones
  
pheromones = generatePheromones(points)

#returns a list of probabilities which edge the ant will follow
def generateProbabilities(currentPoint, remainingPoints):
  probabilities = []
  sumTot = 0
  for i in range(len(points)):
    if i in remainingPoints and i != currentPoint:
      prob = pheromones[currentPoint][i] ** a * (1/distances[currentPoint][i])**b
      #print(1/distances[currentPoint][i])
      probabilities.append(prob)
      sumTot += prob
    else: probabilities.append(0)
  for i in range(len(points)):
    probabilities[i] = probabilities[i] / sumTot
  return probabilities

def generateRoute(antStartingCity):
  visited = [antStartingCity]
  toBeVisited = [i for i in range(len(points))]
  toBeVisited.remove(antStartingCity)
  currentCity = antStartingCity
  while toBeVisited != []:
    probabilities = generateProbabilities(currentCity, toBeVisited)
    chance = random.uniform(0, 1)
    i = 0
    s = 0
    while s < chance:
      s += probabilities[toBeVisited[i]]
      i += 1
    i -= 1
    visited.append(toBeVisited[i])
    currentCity = toBeVisited[i]
    toBeVisited.remove(toBeVisited[i])
  return visited

def decayPheromones():
  for i in range(len(pheromones)):
    for j in range(len(pheromones)):
      pheromones[i][j] = (1-p) * (pheromones[i][j])

#increases pheromons according to performance
def setPheromones(route, routeDistance):
  for i in range(len(route)-1):
      pheromones[route[i]][route[i+1]] = (pheromones[route[i]][route[i+1]]) + (Q / routeDistance)

def generationalColony(anzAnts, nrGenerations):
  ants = []
  for i in range(anzAnts):
      randomPoint = random.randint(0,len(points))
      ants.append(randomPoint)
  currentGen = 0
  globalMin = [[], sys.maxsize]
  while currentGen < nrGenerations:

    minRoute = [[], sys.maxsize]
    antRoutes = []

    for i in range(len(ants)):
      antRoutes.append(generateRoute(ants[i]))

    decayPheromones()
    for routes in antRoutes:
      s = 0
      #print(routes)
      for i in range(len(routes)-1):
        #print(distances[i][i+1])
        s += distances[routes[i]][routes[i+1]]
      s += distances[routes[-1]][routes[0]]
      setPheromones(routes, s)
      #print(s)
    if s < globalMin[1]:
      globalMin[0] = routes
      minRoute[0] = routes
      globalMin[1] = s
      minRoute[1] = s
      print("changedGlobal", s)
    else:
      if s < minRoute[1]:
        minRoute[0] = routes
        minRoute[1] = s
        #print("changedLocal", s)

    currentGen += 1
    #print("currentGen is: ", currentGen)
    #print(minRoute[1])
    if currentGen % 500 == 0 or currentGen == 1:
      print("Current gen: ", currentGen)
      for i in range(len(points)):
        x_plot=[]
        y_plot=[]
        plt.plot(points[i][0],points[i][1],markersize=3, marker="o")
      for i in range(len(points)):
        x_plot.append(points[globalMin[0][i]][0])
        y_plot.append(points[globalMin[0][i]][1])
      x_plot.append(points[globalMin[0][0]][0])
      y_plot.append(points[globalMin[0][0]][1])
      plt.plot(x_plot,y_plot,'r')
      plt.show()

  print("yeehaw", globalMin[1])
  
generationalColony(5, 2000)